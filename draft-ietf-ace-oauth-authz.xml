<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4279 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4279.xml">
<!ENTITY RFC4949 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC6347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC6690 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6690.xml">
<!ENTITY RFC6749 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC6750 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6750.xml">
<!ENTITY RFC6819 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6819.xml">
<!ENTITY RFC7049 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7049.xml">
<!ENTITY RFC7159 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7159.xml">
<!ENTITY RFC7228 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7228.xml">
<!ENTITY RFC7231 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!-- <!ENTITY RFC7250 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7250.xml"> -->
<!ENTITY RFC7252 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7252.xml">
<!ENTITY RFC7516 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7516.xml">
<!ENTITY RFC7517 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7517.xml">
<!ENTITY RFC7519 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7519.xml">
<!-- <!ENTITY I-D.ietf-ace-usecases SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ace-usecases.xml"> -->
<!ENTITY I-D.ietf-oauth-introspection SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-introspection.xml">
<!ENTITY I-D.somaraju-ace-multicast SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.somaraju-ace-multicast.xml">
<!ENTITY I-D.ietf-ace-actors SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ace-actors.xml">
<!ENTITY I-D.ietf-cose-msg SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-cose-msg.xml">
<!ENTITY I-D.selander-ace-object-security SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.selander-ace-object-security.xml">
<!ENTITY I-D.ietf-oauth-pop-architecture SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-pop-architecture.xml">
<!ENTITY I-D.ietf-oauth-pop-key-distribution SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-pop-key-distribution.xml">
<!ENTITY I-D.wahlstroem-ace-oauth-introspection SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.wahlstroem-ace-oauth-introspection.xml">
<!ENTITY I-D.wahlstroem-ace-cbor-web-token SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.wahlstroem-ace-cbor-web-token.xml">
<!ENTITY I-D.bormann-core-ace-aif SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.bormann-core-ace-aif.xml">
<!ENTITY I-D.ietf-core-block SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-block.xml">
<!ENTITY I-D.seitz-ace-core-authz SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.seitz-ace-core-authz.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-ace-oauth-authz-01" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->

    <title abbrev="OAuth 2.0 IoT Authorization">Authorization for the Internet of Things using OAuth 2.0</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Ludwig Seitz" initials="L." surname="Seitz">
      <organization>SICS</organization>

      <address>
        <postal>
          <street>Scheelevaegen 17</street>
          <code>223 70</code> <city>Lund</city>
          <country>SWEDEN</country>
        </postal>
        <email>ludwig@sics.se</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Goeran Selander" initials="G." surname="Selander">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>Faroegatan 6</street>
          <code>164 80</code> <city>Kista</city>
          <country>SWEDEN</country>
        </postal>
        <email>goran.selander@ericsson.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Erik Wahlstroem" initials="E." surname="Wahlstroem">
      <organization>Nexus Technology</organization>

      <address>
        <postal>
          <street>Telefonvagen 26</street>
          <code>126 26</code> <city>Hagersten</city>
          <country>Sweden</country>
        </postal>
        <email>erik.wahlstrom@nexusgroup.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Samuel Erdtman" initials="S." surname="Erdtman">
      <organization>Nexus Technology</organization>

      <address>
        <postal>
          <street>Telefonvagen 26</street>
          <code>126 26</code> <city>Hagersten</city>
          <country>Sweden</country>
        </postal>
        <email>samuel.erdtman@nexusgroup.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
      <organization>ARM Ltd.</organization>

      <address>
        <postal>
          <street></street>
          <code>6060</code> <city>Hall in Tirol</city>
          <country>Austria</country>
        </postal>
        <email>Hannes.Tschofenig@arm.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>
    <date year="2016" />



    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
	 in the current day and month for you. If the year is not the current one, it is
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>Security</area>

    <workgroup>ACE Working Group</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>CoAP, OAuth 2.0, Access Control, Authorization, Internet of Things</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>This memo defines how to use OAuth 2.0 as an authorization framework
      with Internet of Things (IoT) deployments, thus bringing a well-known and
      widely used security solution to IoT devices.  Where possible vanilla
      OAuth 2.0 is used, but where the limitations of IoT devices require it,
      profiles and extensions are provided.
      </t>
    </abstract>
  </front>

<middle>


<!-- ***************************************************** -->

<section anchor="intro" title="Introduction">

<t>Authorization is the process for granting approval to an entity to access a
resource <xref target="RFC4949"/>.  Managing authorization information for a 
large number of devices and users is often a complex task where dedicated 
servers are used.</t>

<t>Managing authorization of users, services and their devices with the help of
dedicated authorization servers (AS) is a common task, found in enterprise
networks as well as on the Web.  In its simplest form the authorization task can
be described as granting access to a requesting client, for a resource hosted on 
a device, the resource server (RS).  This exchange is mediated by one or multiple 
authorization servers.</t>

<t>We envision that end consumers and enterprises will want to manage
access-control and authorization for their Internet of Things (IoT) devices in
the same style and this desire will increase with the number of exposed
services and capabilities provided by applications hosted on the IoT 
devices.  The IoT devices may be constrained in various ways 
including processing, memory, code-size, energy, etc., as defined in
<xref target="RFC7228"/>, and the different IoT deployments present a continuous
range of device and network capabilities.  Taking energy consumption as an
example: At one end there are energy-harvesting or battery powered devices which 
have a tight power budget, on the other end there are devices connected to
a continuous power supply which are not constrained in terms of power, and all 
levels in between.  Thus IoT devices are very different in terms of available 
processing and message exchange capabilities.
</t>

<t>This memo describes how to re-use OAuth 2.0 <xref target="RFC6749"/> to
extend authorization to Internet of Things devices with different kinds of
constraints.  At the time of writing, OAuth 2.0 is already used with certain
types of IoT devices and this document will provide implementers additional
guidance for using it in a secure and privacy-friendly way.  Where possible the
basic OAuth 2.0 mechanisms are used; in some circumstances profiles are defined,
for example to support smaller the over-the-wire message size and
smaller code size.</t>
</section>

<!-- ***************************************************** -->

<section anchor="terminology" title="Terminology">
  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in
this document are to be interpreted as described in <xref
target="RFC2119"/>.  </t>

  <t>Certain security-related terms such as "authentication",
"authorization", "confidentiality", "(data) integrity", "message
authentication code", and "verify" are taken from <xref
target="RFC4949"/>.
  </t>

  <t>Since we describe exchanges as RESTful protocol interactions HTTP
<xref target="RFC7231"/> offers useful terminology.
  </t>

  <t>Terminology for entities in the architecture is defined in OAuth
2.0 <xref target="RFC6749"/> and <xref target="I-D.ietf-ace-actors"/>,
such as client (C), resource server (RS), and authorization server
(AS).  OAuth 2.0 uses the term "endpoint" to denote HTTP resources such as 
/token and /authorize at the AS, but we will use the term "resource" in this 
memo to avoid confusion with the CoAP <xref target="RFC7252"/> term 
"endpoint".</t>

<t>
Since this draft focuses on the problem of access control to resources, we
simplify the actors by assuming that the client authorization server (CAS)
functionality is not stand-alone but subsumed by either the authorization server
or the client (see section 2.2 in <xref target="I-D.ietf-ace-actors"/>).
</t>

</section>

<!-- ***************************************************** -->

<section anchor="overview" title="Overview">

  <t>This specification describes a framework for authorization in the Internet
      of Things consisting of a set of building blocks.</t>

  <t>
  The basic block is the OAuth 2.0 <xref target="RFC6749"/>
  framework, which enjoys widespread deployment.  Many IoT devices can support
  OAuth 2.0 without any additional extensions, but for certain constrained
  settings additional profiling is needed.
  </t>

  <t>Another building block is the lightweight web transfer protocol CoAP
  <xref target="RFC7252"/> for those communication environments where HTTP is
  not appropriate.  CoAP typically runs on top of UDP which further reduces
  overhead and message exchanges.  Transport layer security can be provided
  either by DTLS 1.2 <xref target="RFC6347"/> or TLS 1.2 
  <xref target="RFC5246"/>.
  </t>

  <t>A third building block is CBOR <xref target="RFC7049"/> for encodings
  where JSON <xref target="RFC7159"/> is not sufficiently compact.  CBOR is a 
  binary encoding designed for extremely small code size and fairly small
  message size.  OAuth 2.0 allows access tokens to use different encodings and 
  this document defines such an alternative encoding.  The COSE message format 
  <xref target="I-D.ietf-cose-msg"/> is also based on CBOR.
  </t>

  <t>A fourth building block is application layer security, which is used
  where transport layer security is insufficient.  At the time of writing
  the preferred approach for securing CoAP at the application layer is via the
  use of COSE <xref target="I-D.ietf-cose-msg"/>, which adds object security to
  CBOR-encoded data.  More details about applying COSE to CoAP can be found in
  OSCOAP <xref target="I-D.selander-ace-object-security"/>.
  </t>

  <t>With the building blocks listed above, solutions satisfying various
  IoT device and network constraints are possible.  A list of constraints is
  described in detail in RFC 7228 <xref target="RFC7228"/> and a description
  of how the building blocks mentioned above relate to the various constraints
  can be found in <xref target="constraints"/>.</t>


  <t>Luckily, not every IoT device suffers from all constraints.  The described
  framework nevertheless takes all these aspects into account and allows 
  several different deployment variants to co-exist rather than mandating a
  one-size-fits-all solution.  We believe this is important to cover the wide
  range of possible interworking use cases and the different requirements from 
  a security point of view.  Once IoT deployments mature, popular deployment
  variants will be documented in form of profiles.</t>

  <t>In the subsections below we provide further details about the different
  building blocks.</t>

  <section anchor="oauth2Overview" title="OAuth 2.0">
    <t>The OAuth 2.0 authorization framework enables a client to obtain
    limited access to a resource with the permission of a resource 
    owner.  Authorization related information is passed between the nodes
    using access tokens.  These access tokens are issued to clients by an
    authorization server with the approval of the resource owner.  The client
    uses the access token to access the protected resources hosted by the
    resource server.</t>

    <t>A number of OAuth 2.0 terms are used within this memo:

    <list style="hanging">

      <t hangText="Access Tokens:"><vspace blankLines="1"/>
        Access tokens are credentials used to access protected resources.  An
        access token is a data structure representing authorization permissions
        issued to the client.  Access tokens are generated by the authorization 
        server and consumed by the resource server.  The access token is opaque 
        to the client.
        <vspace blankLines="1"/>
        Access tokens can have different formats, and various methods
        of utilization (e.g., cryptographic properties) based on the security
        requirements of the given deployment.
      </t>

      <t hangText="Proof of Possession Tokens:"><vspace blankLines="1"/>
        An access token may be bound to a
        cryptographic key, which is then used by an RS to authenticate requests
        from a client.  Such tokens are called proof-of-possession tokens (or
        PoP tokens) <xref target="I-D.ietf-oauth-pop-architecture"/>.
        <vspace blankLines="1"/>
        The proof-of-possession (PoP) security concept assumes that the AS acts
        as a trusted third party that binds keys to access tokens.  These so
        called PoP keys are then used by the client to demonstrate the
        possession of the secret to the RS when accessing the resource.  The
        RS, when receiving an access token, needs to verify that the key used
        by the client matches the one included in the access token.  When this 
        memo uses the term "access token" it is assumed to be a PoP token unless
        specifically stated otherwise.

        <vspace blankLines="1"/>
        The key bound to the access token (aka PoP key) may be based on
        symmetric as well as on asymmetric cryptography.  The appropriate
        choice of security depends on the constraints of the IoT devices as
        well as on the security requirements of the use case.

        <list style="hanging">
          <t hangText="Symmetric PoP key:"><vspace blankLines="1"/>
              The AS generates a random symmetric PoP key, encrypts it for the 
              RS and includes it inside an access token.  The PoP key is also
              encrypted for the client and sent together with the access token
              to the client.
          </t>
          <t hangText="Asymmetric PoP key:"><vspace blankLines="1"/>
              An asymmetric key pair is generated on the client and the public
              key is sent to the AS (if it does not already have knowledge of
              the client's public key).  Information about the public key,
              which is the PoP key in this case, is then included inside the
              access token and sent back to the requesting client.  The RS
	      can identify the client's public key from the information in the
	      token, which allows the client to use the corresponding private
	      key for the proof of possession.
          </t>
        </list>
        <vspace blankLines="1"/> The access token is
        protected against modifications using a MAC or a digital signature
        of the AS.  The choice of PoP key does not necessarily imply a specific
        credential type for the integrity protection of the token.  More
        information about PoP tokens can be found in
        <xref target="I-D.ietf-oauth-pop-architecture"/>.
      </t>

      <t hangText="Scopes and Permissions:"><vspace blankLines="1"/>
         In OAuth 2.0, the client specifies the type of permissions it is
         seeking to obtain (via the scope parameter) in the access request.  In
         turn, the AS may use the "scope" response parameter to inform the
         client of the scope of the access token issued.  As the client could
	 be a constrained device as well, this memo uses CBOR encoded messages 
         defined in <xref target="app:cborMappingsForOAuth2Properties" /> to 
         request scopes and to be informed what scopes the access token was 
         actually authorized for by the AS.
         <vspace blankLines="1"/>
         The values of the scope parameter are expressed as a list of space-
         delimited, case-sensitive strings, with a semantic that is well-known
	 to the AS and the RS.
         <!-- <vspace blankLines="1"/>
         A common misconception is that the requested scopes must
         also be included in the returned access token, but the requested scopes
         are only metadata about the token.  They could also be packaged in the
         token as a separate attribute, but it's more common to assert the
         requested and authorized access using claims within the access token.
         <vspace blankLines="1"/>-->
         More details about the concept of scopes is found under Section 3.3 in
         <xref target="RFC6749" />.
      </t>


      <t hangText="Claims:"><vspace blankLines="1"/>

        The information carried in the access token in the form of type-value 
        pairs is called claims.  An access token may for example include a claim
        about the AS that issued the token (the "iss" claim) and what audience
        the access token is intended for (the "aud" claim).  The audience of an
        access token can be a specific resource or one or many resource 
        servers.  The resource owner policies influence the what claims are put 
        into the access token by the authorization server.
        <vspace blankLines="1"/>
        While the structure and encoding of the access token varies throughout 
        deployments, a standardized format has been defined with the JSON Web 
        Token (JWT) <xref target="RFC7519"/> where claims are encoded as a JSON 
        object.  In <xref target="I-D.wahlstroem-ace-cbor-web-token"/> an
	equivalent format using CBOR encoding (CWT) has been defined.
      </t>

      <t hangText="Introspection:"><vspace blankLines="1"/>
        Introspection is a method for a resource server to query the
        authorization server for the active state and content of a received
        access token.  This is particularly useful in those cases where the
        authorization decisions are very dynamic and/or where the received
        access token itself is a reference rather than a self-contained
        token.   More information about introspection in OAuth 2.0 can be
        found in <xref target="I-D.ietf-oauth-introspection"/>.
      </t>
    </list>
  </t>
</section>

<section anchor="coap" title="CoAP">

    <t>
    CoAP is an application layer protocol similar to HTTP, but specifically
    designed for constrained environments.  CoAP typically uses
    datagram-oriented transport, such as UDP, where reordering and loss
    of packets can occur.  A security solution need to take the latter aspects
    into account.</t>

    <t>While HTTP uses headers and query-strings to convey additional
    information about a request, CoAP encodes such information in so-called
    'options'.</t>

    <t>CoAP supports application-layer fragmentation of the CoAP payloads
    through blockwise transfers <xref target="I-D.ietf-core-block"/>.  However,
    this method does not allow the fragmentation of large CoAP options,
    therefore data encoded in options has to be kept small.
   <!-- Note that the use of block transfers prevents
        end-to-end security since
    some operations by proxies requires access to meta-data. --> </t>

</section>

<section anchor="objectsecurity" title="Object Security">

  <t>Transport layer security is not always sufficient and application layer
  security has to be provided.  COSE <xref target="I-D.ietf-cose-msg"/> defines
  a message format for cryptographic protection of data using CBOR encoding.
  There are two main approaches for application layer security:

  <list style="hanging">
    <t hangText="Object Security of CoAP (OSCOAP)"><vspace blankLines="1"/>
    OSCOAP <xref target="I-D.selander-ace-object-security"/> is a method for
    protecting CoAP request/response message exchanges, including CoAP
    payloads, CoAP header fields as well as CoAP options.  OSCOAP provides
    end-to-end confidentiality, integrity and replay protection, and a secure
    binding between CoAP request and response messages.
    <vspace blankLines="1"/>
    A CoAP message
    protected with OSCOAP contains the CoAP option "Object-Security"
    which signals that the CoAP message carries a COSE message
    (<xref target="I-D.ietf-cose-msg"/>).  OSCOAP defines a profile of COSE
    which includes replay protection.</t>

    <t hangText="Object Security of Content (OSCON)"><vspace blankLines="1"/>
    For the case of wrapping of application layer payload data ("content")
    only, such as resource representations or claims of access tokens,
    the same COSE profile can be applied to obtain end-to-end
    confidentiality, integrity and replay protection.
    <xref target="I-D.selander-ace-object-security"/> defines this functionality
    as Object Security of Content (OSCON).
    <vspace blankLines="1"/>
    In this case, the message is not
    bound to the underlying application layer protocol and can therefore be used
    with HTTP, CoAP, Bluetooth Smart, etc.  While OSCOAP integrity protects
    specific CoAP message meta-data like request/response code, and binds a
    response to a specific request, OSCON protects only payload/content,
    therefore those security features are lost.  The advantages are that an 
    OSCON message can be passed across different protocols, from request to 
    response, and used to secure group communications.
   <!-- <vspace blankLines="1"/>
    OSCON is, for example, used in this memo for protection of CBOR Web Tokens 
    (CWT) and in example <xref target="ExRSKindaOff"/>.-->
    </t>
  </list></t>
</section>
</section>


<!-- ***************************************************** -->
<section anchor="specs" title="Protocol Interactions">

<t>
    This framework is based on the same protocol interactions as OAuth 2.0:
    A client obtains an access token from an AS and presents the token
    to an RS to gain access to a protected resource.  These interactions are
    shown in <xref target="fig:protocolFlow"/>.  An overview of various OAuth 
    concepts is provided in <xref target="oauth2Overview"/>.
</t>

<t>
    The consent of the resource owner, for giving a client access to a protected
    resource, can be pre-configured authorization policies or dynamically at the
    time when the request is sent.  The resource owner and the requesting
    party (= client owner) are not shown in <xref target="fig:protocolFlow"/>.
</t>

<t>
  For the description in this document we assume that the client has been 
  registered to an AS.  Registration means that the two share credentials, 
  configuration parameters and that some form of authorization has taken 
  place.  These credentials are used to protect the token request by the 
  client and the transport of access tokens and client information from AS 
  to the client. </t> 

 <t>It is also assumed
  that the RS has been registered with the AS.  Established keying material 
between the AS and the RS allows the AS to apply cryptographic protection 
to the access token to ensure that the content cannot be modified, and if
needed, that the content is confidentiality protected.</t> 

<t>The keying material necessary for establishing communication security
  between C and RS is dynamically established as part of the protocol described 
  in this document.
</t>

<t>
    At the start of the protocol there is an optional discovery step where the
    client discovers the resource server and the resources this server hosts.
    In this step the client might also determine what permissions are needed to
    access the protected resource.  The exact procedure depends on the
    protocols being used and the specific deployment environment.  In Bluetooth
    Smart, for example, advertisements are broadcasted by a peripheral,
    including information about the supported services.  In CoAP, as a second
    example, a client can makes a request to "/.well-known/core" to obtain
    information about available resources, which are returned in a
    standardized format as described in <xref target="RFC6690"/>.
</t>

<t><figure align="center" anchor="fig:protocolFlow"
           title="Overview of the basic protocol flow">
  <artwork align="left"><![CDATA[
+--------+                                     +---------------+
|        |---(A)-- Token Request ------------->|               |
|        |                                     | Authorization |
|        |<--(B)-- Access Token ---------------|    Server     |
|        |       + Client Information          |               |
|        |                                     +---------------+
|        |                                            ^ |
|        |        Introspection Request & Response (D)| |(E)
| Client |                                            | v
|        |                                     +--------------+
|        |---(C)-- Token + Request ----------->|              |
|        |                                     |   Resource   |
|        |<--(F)-- Protected Resource ---------|    Server    |
|        |                                     |              |
+--------+                                     +--------------+
  ]]></artwork>
</figure></t>

<t>
  <list style="hanging">
    <t hangText="Requesting an Access Token (A):"><vspace blankLines="1"/>
      The client makes an access token request to the AS.  This memo assumes
      the use of PoP tokens (see <xref target="oauth2Overview"/> for a short
      description) wherein the AS binds a key to an access token.  The client
      may include permissions it seeks to obtain, and information about the
      type of credentials it wants to use (i.e., symmetric or asymmetric
      cryptography).
    </t>

    <t hangText="Access Token Response (B):"><vspace blankLines="1"/>
      If the AS successfully processes the request from the client, it returns 
      an access token.  It also includes various parameters, which we call 
      "Client Information".  In addition to the response parameters defined by 
      OAuth 2.0 and the PoP token extension, we consider new kinds of response 
      parameters in <xref target="specsClientInfo"/>, including information on 
      which security protocol the client should use with the resource server(s)
      that it has just been authorized to access.  Communication security
      between client and RS may be based on pre-provisioned keys/security
      contexts or dynamically established. The RS authenticates the client via 
      the PoP token; and the client authenticates the RS via the client 
      information as described in
      <xref target="oauth2ProfilesCSP"/>.
    </t>

    <t hangText="Resource Request (C):"><vspace blankLines="1"/>
      The client interacts with the RS to request access to the protected
      resource and provides the access token.  The protocol to use
      between the client and the RS is not restricted to CoAP; HTTP, HTTP/2,
      Bluetooth Smart etc., are also possible candidates. 
      <vspace blankLines="1"/>
      Depending on the device limitations and the selected protocol this
      exchange may be split up into two phases: 

<list style="empty">
<t>(1) the client sends the access token
      to a newly defined authorization endpoint at the RS (see <xref target="oauth2ProfilesAuthzInfo"/>)
      , which conveys authorization information to the RS that may be used by the client for
      subsequent resource requests, and </t> 
<t>(2) the client makes the resource access request, using the communication security protocol and other
    client information obtained from the AS.</t>
</list> 

      <vspace blankLines="1"/>
      The RS verifies that the token is integrity protected by the AS and 
      compares the claims contained in the access token with the resource 
      request.  If the RS is online, validation can be handed over to the AS
      using token introspection (see messages D and E) over HTTP or CoAP, in
      which case the different parts of step C may be interleaved with
      introspection.
    </t>

    <t hangText="Token Introspection Request (D):"><vspace blankLines="1"/>
      A resource server may be configured to use token introspection to
      interact with the AS to obtain the most recent claims, such as scope,
      audience, validity etc. 
      associated with a specific access token.  Token introspection over
      CoAP is defined in
      <xref target="I-D.wahlstroem-ace-oauth-introspection"/> and for HTTP in 
      <xref target="I-D.ietf-oauth-introspection"/>.
      <vspace blankLines="1"/>
      Note that token introspection is an optional step and can be omitted if
      the token is self-contained and the resource server is prepared to
      perform the token validation on its own.
    </t>

    <t hangText="Token Introspection Response (E):"><vspace blankLines="1"/>
      The AS validates the token and returns the claims associated with it
      back to the RS.  The RS then uses the received claims to process the
      request to either accept or to deny it.
    </t>

    <t hangText="Protected Resource (F):"><vspace blankLines="1"/>
      If the request from the client is authorized, the RS fulfills the request 
      and returns a response with the appropriate response code.  The RS uses the
      dynamically established keys to protect the response, according to used
      communication security protocol.
    </t>
  </list>
  </t>
</section>



<!-- ***************************************************** -->

<section anchor="specsClientInfo" title="OAuth 2.0 Profiling">

  <t>
    This section describes profiles of OAuth 2.0 adjusting it to constrained
    environments for use cases where this is necessary.  Profiling for
    JSON Web Tokens (JWT) is provided in 
    <xref target="I-D.wahlstroem-ace-cbor-web-token"/>.
  </t>



<section anchor="oauth2ProfilesCSP" title="Client Information">
    
    <t>OAuth 2.0 using bearer tokens, as described in <xref
    target="RFC6749"/> and in <xref target="RFC6750"/>, 
    requires TLS for all communication interactions between client, 
    authorization server, and resource server.  This is possible in the scope
    where OAuth 2.0 was originally developed: web and mobile applications.  In
    these environments resources like computational power and bandwidth are
    not scarce and operating systems as well as browser platforms are 
    pre-provisioned with trust anchors that enable clients to authenticate
    servers based on the Web PKI.  In a more heterogeneous IoT environment a 
    wider range of use cases needs to be supported.  Therefore, this document
    suggests extensions to OAuth 2.0 that enables the AS to inform the client 
    on how to communicate securely with a RS and that allows the client to 
    indicate communication security preferences to the AS.</t>
    
    <t>In the OAuth memo defining the key distribution for
    proof-of-possession (PoP) tokens <xref
    target="I-D.ietf-oauth-pop-key-distribution"/>,  the authors suggest to
    use Uri-query parameters in order to submit the parameters of the client's
    token request.  To avoid large headers if the client uses CoAP to
    communicate with the AS, this memo specifies the following alternative for
    submitting client request parameters to the AS: The client encodes the
    parameters of its request as a CBOR map and submits that map as the
    payload of the client request.  The Content-format MUST be
    application/cbor in that case.</t>
    
    <t>The OAuth memo further specifies that the AS SHALL use a JSON
    structure in the payload of the response to encode the response
    parameters.  These parameters include the access token, destined
    for the RS and additional information for the client, such as e.g. the PoP
    key.  We call this information "client information".  If the client is
    using CoAP to communicate with the AS the AS SHOULD use CBOR instead of
    JSON for encoding its response.  The client can explicitly request this
    encoding by setting the CoAP Accept option in the access token request to
    "application/cbor".</t>

    <t>If the channel between client and AS is not secure, the whole messages 
    from client to AS and vice-versa MUST be wrapped in JWEs 
    <xref target="RFC7516"/> or COSE_Encrypted structures <xref 
    target="I-D.ietf-cose-msg"/>.  The client can explicitly request COSE
    wrapping by setting the CoAP Accept option to "application/cose".</t>

    <t>The client may be a constrained device and could therefore be limited
    in the communication security protocols it supports.  It can therefore
    signal to the AS which protocols it can support for securing their 
    mutual communication.  This is done by using the "csp" parameter defined
    below in the Token Request message sent to the AS.</t>

    <t>Note that The OAuth key distribution specification <xref
    target="I-D.ietf-oauth-pop-key-distribution"/> describes in section 6
    how the client can request specific types of keys (symmetric vs. 
    asymmetric) and proof-of-possession algorithms in the PoP token
    request.  These are used as well in this specification.</t>

    <t>The client and the RS might not have any prior knowledge about each 
    other, therefore the AS needs to help them to establish a security context 
    or at least a common key.  The AS does this by indicating the
    communication security  protocol parameter "csp" and additional key
    parameters in the client information.</t>
    
    <t>The csp parameter specifies how client and RS communication is going to
    be secured based on the keys provided by the AS.  Currently defined values
    are "TLS",  "DTLS", "ObjectSecurity" with the encodings specified in
    <xref target="tab:cspParam"/>.  Depending on the value different
    additional parameters become mandatory.</t>
    
    <t><figure align="center" anchor="tab:cspParam"
               title="Table of 'csp' parameter value encodings for Client 
		      Information.">
      <artwork align="left"><![CDATA[
       /-----------+--------------+-----------------------\
       | Value     | Major Type   | Key                   |
       |-----------+--------------+-----------------------|
       | 0         | 0            | TLS                   |
       | 1         | 0            | DTLS                  |
       | 2         | 0            | ObjectSecurity        |
       \-----------+--------------+-----------------------/
      ]]></artwork>
    </figure></t>

    <t>CoAP specifies three security modes of DTLS: PreSharedKey, RawPublicKey
    and Certificate.  The same modes can be used with TLS.  The client is to
    infer from the type of key provided, which (D)TLS mode the RS supports as
    follows.</t>

    <t>If PreSharedKey mode is used, the AS MUST provide the client with 
    the pre-shared key to be used with the RS.  This key MUST be the same as
    the PoP key (i.e. a symmetric key as in section 4 of <xref
    target="I-D.ietf-oauth-pop-key-distribution"/>).</t>

    <t>The client MUST use the PoP key as DTLS pre-shared key.  The client 
    MUST furthermore use the "kid" parameter provided as part of the 
    JWK/COSE_Key as the psk_identity in the DTLS handshake <xref 
    target="RFC4279"/>.  How the AS and the RS determine the values of the kid
    parameter is out of scope for this specification, but the AS MUST use a
    kid that makes it possible for the RS to select the correct key.</t>
    
    <t>If RawPublicKey mode is used, the AS MUST provide the client with 
    the RS's raw public key using the "rpk" parameter defined in the
    following.  This parameter MUST contain a JWK or a COSE_Key.  The client
    MUST provide a raw public key to the AS, and the AS MUST use this key as
    PoP key in the token.  The token MUST thus use asymmetric keys for the 
    proof-of-possession.  Note that the PoP key distribution specification
    <xref target="I-D.ietf-oauth-pop-key-distribution"/> defines how the
    client can transfer its key as a JWK datastructure.  This specification
    RECOMMENDS to use a COSE_Key structure instead.  This specification refers
    to section 9.1.3.2.1. of CoAP <xref target="RFC7252"/> for recommendations
    on how to generate the kid for a raw public key.</t>
    
    <t>In order to get the proof-of-possession a RS configured to use this
    mode together with PoP tokens MUST require client authentication in the 
    DTLS handshake.  The client MUST use the raw public key bound to the
    PoP token for client authentication in DTLS.</t>    
  
    <t>TLS or DTLS with certificates MAY make use of pre-established trust
    anchors or MAY be configured more tightly with additional client
    information parameters, such as x5c, x5t, or x5t#S256. An overview of
    these parameters is given below.</t>

    <t hangText="X.509 Certificate Chain (x5c)"><vspace blankLines="1"/>
    For when communication security is based on certificates this attribute
    can be used to define the server certificate or CA certificate.
    Semantics for this attribute is defined by <xref target="RFC7517"/> or
    COSE_Key <xref target="I-D.ietf-cose-msg"/>.</t>
   
    <t hangText="X.509 Certificate Thumbprint (x5t and x5t#S256)">
    <vspace blankLines="1"/>
    For when communication security is based on certificates this attribute
    can be used to define the specific server certificate to expect or the CA
    certificate.  Semantics for this attribute is defined by JWK/COSE_Key.</t>
                   
    <t>To use object security (such as OSCOAP and OSCON) requires security
    context to be established, which can be provisioned with PoP token and
    client information, or derived from that information. Object security
    specifications designed to be used with this protocol MUST specify the
    parameters that an AS has to provide to the client in order to set up
    the necessary security context.</t>
  
    <t>Table <xref target="tab:cspSummary"/> summarizes the additional
    parameters defined here for use by the client or the AS in the
    PoP token request protocol.</t>
    <t><figure align="center" anchor="tab:cspSummary"
               title="Table of additional parameters defined for the
		      PoP protocol.">
      <artwork align="left"><![CDATA[
   /-----------+--------------+----------------------------------\
   | Parameter | Used by      | Description                      |
   |-----------+--------------+----------------------------------|
   | csp       | client or AS | Communication security protocol  |
   | rpk       | AS           | RS's raw public key              |
   | x5c       | AS           | RS's X.509 certificate chain     |
   | x5t       | AS           | RS's SHA-1 cert thumb print      |
   | x5t#S256  | AS           | RS's SHA-256 cert thumb print    |
   \-----------+--------------+----------------------------------/
      ]]></artwork>
    </figure></t>
  </section>

  <section anchor="oauth2ProfilesCoAPAccessTokenOption"
           title="CoAP Access-Token Option">
    <t> OAuth 2.0 access tokens are usually transferred as authorization 
    	header. CoAP has no authorization header equivalence. This document 
    	therefor register the option Access-Token. The Access-Token option 
    	is an alternative for transferring the access token when it is smaller 
    	then 255 bytes. If token is larger the 255 bytes lager authorization 
    	information resources MUST at the RS be user when CoAP.
    </t>
  </section>

<section anchor="oauth2ProfilesAuthzInfo"
           title="Authorization Information Resource at the Resource Server">
    <t>A consequence of allowing the use of CoAP as web transfer protocol
      is that we cannot rely on HTTP specific mechanisms, such as
      transferring information elements in HTTP headers since those are not
      necessarily gracefully mapped to CoAP.  In case the access token is
      larger than 255 bytes it should not be sent as a CoAP option.
    </t>
    <t>For conveying authorization information to the RS a new resource is 
      introduced to which the PoP tokens can be sent to
      convey authorization information before the first resource request is made
      by the client.  This specification calls this resource "/authz-info"; the 
      URI may, however, vary in deployments.
    </t>
    <t>The RS needs to store the PoP token for when later
      authorizing requests from the client. The RS is not mandated 
      to be able to manage multiple client at once. how the RS manages 
      clients is out of scope for this specification.
    </t>

    <section anchor="authzInfoResourceRequest" 
             title="Authorization Information Request">
    <t>The client makes a POST request to the authorization information
      resource by sending its PoP token as request data.</t>
    <t>Client MUST send the Content-Format option indicate token format</t>
    <!-- TODO insert Content-Format -->

    </section>
      <section anchor="authzInfoResourceResponse" 
               title="Authorization Information Response">
        <t>The RS MUST resonde to a requests to the authorization 
          information resource. The response MUST match CoAP response 
          codes according to success or error response section</t>

      <section anchor="authzInfoResourceSuccessResponse"
               title="Success Response">
        <t>Successful requests MUST be answered with 2.01 
          Created to indicate that a "session" for the PoP 
          Token has been created. No location path is 
          required to be returned.
        </t>
        <t>
          <figure align="center" anchor="fig:clientRSAuthzInfoSuccess"
                   title="Authorization Information Resource Success Response">
            <artwork align="left"><![CDATA[
          Resource
  Client   Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    | POST    | Uri-Path: "/authz-info"
    |         | Content-Format: "application/cwt"
    |         | Payload: <PoP Token>
    |         |
B:  |<--------+ Header: 2.01 Created
    | 2.01    | 
    |         | 
        ]]>
            </artwork>
          </figure>
        </t>
      </section>

      <section anchor="authzInfoResourceErrorResponse"
               title="Error Response">
        <t>The resource server MUST user appropriate CoAP 
          response code to convey the error to the Client.
          For request that are not valid, e.g. unknown Content-Format, 
          4.00 Bad Request MUST be returned. If token is not valid, 
          e.g. wrong audience, the RS MUST return 4.01 Unauthorized.
        </t>
        <t>
          <figure align="center" anchor="fig:clientRSAuthzInfoError"
                   title="Authorization Information Resource Error Response">
            <artwork align="left"><![CDATA[
          Resource
  Client   Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    | POST    | Uri-Path: "/authz-info"
    |         | Content-Format: "application/cwt"
    |         | Payload: <PoP Token>
    |         |
B:  |<--------+ Header: 4.01 Unauthorized
    | 2.01    | 
    |         | 
        ]]>
            </artwork>
          </figure>
        </t>
      </section>
    </section>
  </section>

<section anchor="aifsection"
    title="Authorization Information Format">
    <t>We introduce a new claim for describing access rights with a specific 
    format, the "aif" claim.  In this memo we propose to use the compact 
    format provided by AIF  <xref target="I-D.bormann-core-ace-aif" />.  Access 
    rights may be specified as a list of URIs of resources together with allowed 
    actions (GET, POST, PUT, PATCH, or DELETE).  Other formats may be mandated
    by specific applications or requirements (e.g. specifying local conditions
    on access).
    </t>
</section>


<section anchor="oauth2ProfilesCBOR" title="CBOR Data Formats">
    <t>
        The /token resource (called "endpoint" in OAuth 2.0), defined in Section
        3.2 of <xref target="RFC6749" />, is used by the client to obtain an
        access token.  Requests sent to the /token resource use the HTTP POST 
        method and the payload includes a query component, which is formatted as
        application/x-www-form-urlencoded.  CoAP payloads cannot be formatted in
        the same way which requires the /token resource on the AS to be 
        profiled.
        <!-- FIXME: The CoAP specific information could be moved to section 4.
         -->
        
        <xref target="app:cborMappingsForOAuth2Properties" /> defines a 
        CBOR-based format for sending parameters to the /token resource.
    </t>
</section>

<section anchor="tokenValidity" title="Token Expiration">
    <t>Depending on the capabilities of the RS, there are various ways in
    which it can verify the validity of a received access token.  We list the
    possibilities here including what functionality they require of the
    RS.</t>
    
    <t><list style="symbols">
      <t>The token is a CWT/JWT and includes a 'exp' claim and possibly the
      'nbf' claim.  The RS verifies these by comparing them to values from 
      its internal clock as defined in <xref target="RFC7519"/>.  In this
      case the RS must have a real time chip (RTC) or some other way of 
      reliably measuring time.</t>

      <t>The RS verifies the validity of the token by performing an
      introspection request as specified in <xref
      target="introspectionResource"/>.  This requires the RS to have a
      reliable network connection to the AS and to be able to handle two
      secure sessions in parallel (C to RS and AS to RS).</t>

      <t>The RS and the AS both store a sequence number linked to their common
      security association.  The AS increments this number for each access
      token it issues and includes it in the access token, which is a
      CWT/JWT.  The RS keeps track of the most recently received sequence
      number, and only accepts tokens as valid, that are in a certain range
      around this number.  This method does only require the RS to keep track
      of the sequence number.  The method does not provide timely expiration,
      but it makes sure that older tokens cease to be valid after a specified
      number of newer ones got issued.  For a constrained RS with no network
      connectivity and no means of reliably measuring time, this is the best
      that can be achieved.</t>      

    </list></t>
</section>


</section>

    <section anchor="security" title="Security Considerations">
      <t>The entire document is about security.  Security considerations
      applicable to authentication and authorization in RESTful
      environments provided in OAuth 2.0 <xref target="RFC6749"/> apply to this
      work, as well as the security considerations from
      <xref target="I-D.ietf-ace-actors"/>.  Furthermore 
      <xref target="RFC6819"/> provides additional security considerations for
      OAuth which apply to IoT deployments as well.  Finally 
      <xref target="I-D.ietf-oauth-pop-architecture"/> discusses security
      and privacy threats as well as mitigation measures for Proof-of-Possession
      tokens.</t>
    </section>

    <section anchor="iana" title="IANA Considerations">
      <t>TBD</t>
      <t>FIXME: Add registry over 'csp' values from Figure 2</t>
      <t>FIXME: Add registry of 'rpk' parameter from section 5.1</t>
      <t>FIXME: Add registry of 'tktn' values from Figure 3</t>

      <section anchor="CoAPOptionNumberRegistration" title="CoAP Option Number Registration">
      	<t>
      		This section registers the "Access-Token" CoAP Option Number [RFC2046] in
      		"CoRE Parameters" sub-registry "CoAP Option Numbers" in the manner described
      		in [RFC7252].
      	</t>
        <t>
          <list style="hanging">
            <t hangText="Name"><vspace blankLines="1"/>
              Access-Token
           </t>
            <t hangText="Number"><vspace blankLines="1"/>
              TBD
            </t>
            <t hangText="Reference"><vspace blankLines="1"/>
              [draft-ietf-ace-oauth-authz]
            </t>
            <t hangText="Meaning in Request"><vspace blankLines="1"/>
              Contains an Access Token according to [draft-ietf-ace-oauth-authz] 
              containing access permissions of the client.
            </t>
            <t hangText="Meaning in Response"><vspace blankLines="1"/>
              Not used in response
            </t>
            <t hangText="Safe-to-Forward"><vspace blankLines="1"/>
              TBD
            </t>
            <t hangText="Format"><vspace blankLines="1"/>
              Based on the observer the format is perseved differently. 
              Opaque data to the client and CWT or reference token to the RS.
            </t>
            <t hangText="Length"><vspace blankLines="1"/>
              Less then 255 bytes
            </t>
          </list>
        </t>
      </section>
    </section>


    <section anchor="Acknowledgments" title="Acknowledgments">
        <t>We would like to thank Eve Maler for her contributions to the use of 
        OAuth 2.0 and UMA in IoT scenarios, Robert Taylor for his discussion 
        input, and Malisa Vucinic for his input on the ACRE proposal 
	<xref target="I-D.seitz-ace-core-authz"/> which was one source of 
        inspiration for this work. Finally, we would like to thank the ACE 
        working group in general for their feedback.</t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &I-D.ietf-cose-msg;

      &I-D.selander-ace-object-security;

      &I-D.ietf-oauth-pop-architecture;

      &I-D.ietf-oauth-pop-key-distribution;

      &I-D.wahlstroem-ace-oauth-introspection;

      &I-D.wahlstroem-ace-cbor-web-token;

      &I-D.ietf-oauth-introspection;

      &I-D.bormann-core-ace-aif;

      &RFC2119;

      &RFC4279;

      &RFC6347;

      &RFC7252;
      
      &RFC7516;     

      &RFC7517;

    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->
      <!-- &I-D.ietf-ace-usecases;
      &RFC7250;

-->

      &I-D.somaraju-ace-multicast; 
   
      &I-D.seitz-ace-core-authz;

      &I-D.ietf-ace-actors;

      &I-D.ietf-core-block;

      &RFC4949;

      &RFC5246;

      &RFC6690;

      &RFC6749;

      &RFC6750;
      
      &RFC6819;

      &RFC7049;

      &RFC7159;

      &RFC7228;

      &RFC7231;

      &RFC7519;

    </references>

    <section title="Design Justification" anchor="constraints">

     <t>This section provides further insight into the design decisions
     of the solution documented in this document.  <xref target="overview"/>
     lists several building blocks and briefly summarizes their importance.
     The justification for offering some of those building blocks, as opposed
     to using OAuth 2.0 as is, is given below.</t>

     <t>Common IoT constraints are:

        <list style="hanging">

          <t hangText="Low Power Radio:"><vspace blankLines="1"/>
          Many IoT devices are equipped with a small battery which needs
          to last for a long time.  For many constrained wireless devices the
          highest energy cost is associated to transmitting or receiving
          messages.  It is therefore important to keep the total communication
          overhead low, including minimizing the number and size of messages
          sent and received, which has an impact of choice on the message format
          and protocol.  By using CoAP over UDP, and CBOR encoded messages
          some of these aspects are addressed.  Security protocols contribute
          to the communication overhead and can in some cases be
          optimized.  For example authentication and key establishment may in
          certain cases where security requirements so allows be replaced by
          provisioning of security context by a trusted third party, using
          transport or application layer security.
          </t>

          <t hangText="Low CPU Speed:"><vspace blankLines="1"/>
          Some IoT devices are equipped with processors that are significantly
          slower than those found in most current devices on the Internet.
          This typically has implications on what timely cryptographic
          operations a device is capable to perform, which in turn impacts
          e.g. protocol latency.  Symmetric key cryptography may be used
          instead of the computationally more expensive public key cryptography
          where the security requirements so allows, but this may also require
          support for trusted third party assisted secret key establishment
          using transport or application layer security.
          </t>

          <t hangText="Small Amount of Memory:"> <vspace blankLines="1"/>
          Microcontrollers embedded in IoT devices are often equipped with
          small amount of RAM and flash memory, which places limitations what
          kind of processing can be performed and how much code can be put on
          those devices.  To reduce code size fewer and smaller protocol
          implementations can be put on the firmware of such a device.  In
          this case, CoAP may be used instead of HTTP,  symmetric key
          cryptography instead of public key cryptography, and CBOR instead of
          JSON.  Authentication and key establishment protocol, e.g. the DTLS
          handshake,  in comparison with assisted key establishment also has
          an impact on memory and code.
          </t>

          <t hangText="User Interface Limitations:"> <vspace blankLines="1"/>
          Protecting access to resources is both an important security as well
          as privacy feature.  End users and enterprise customers do not want
          to give access to the data collected by their IoT device or to
          functions it may offer to third parties.  Since the classical
          approach of requesting permissions from end users via a rich user
          interface does not work in many IoT deployment scenarios these
          functions need to be delegated to user controlled devices that are
          better suitable for such tasks, such as smart phones and tablets.</t>

          <t hangText="Communication Constraints:"> <vspace blankLines="1"/>
          In certain constrained settings an IoT device may not be able to
          communicate with a given device at all times.  Devices may be
          sleeping, or just disconnected from the Internet because of general
          lack of connectivity in the area, for cost reasons, or for security
          reasons, e.g. to avoid an entry point for Denial-of-Service attacks.

          <vspace blankLines="1"/>
          The communication interactions this framework builds upon (as shown
          graphically in <xref target="fig:protocolFlow"/>) may be accomplished
          using a variety of different protocols, and not all parts of the
          message flow are used in all applications due to the communication
          constraints.  While we envision deployments to make use of CoAP we
          explicitly want to support HTTP, HTTP/2 or specific protocols, such
          as Bluetooth Smart communication, which does not necessarily use
          IP.  The latter raises the  need for application layer security over
          the various interfaces.
          </t>

        </list>
      </t>

    </section>

    <section anchor="app:rolesAndResponsibilities" title="Roles and
      Responsibilites -- a Checklist">
      <t><list style="hanging">
	<t hangText="Resource Owner">
	  <list style="symbols">
	    <t>Make sure that the RS is registered at the AS.</t>
	    <t>Make sure that clients can discover the AS which is in charge
	    of the RS.</t>
	    <t>Make sure that the AS has the necessary, up-to-date, access 
	    control policies for the RS.</t>
	  </list>
	</t>
	<t hangText="Requesting Party">
	  <list style="symbols">
	    <t>Make sure that the client is provisioned the necessary
	    credentials to authenticate to the AS.</t>
	    <t>Make sure that the client is configured to follow the security
	    requirements of the Requesting Party, when issuing requests
	    (e.g. minimum communication security requirements, trust
	    anchors).</t>
	    <t>Register the client at the AS.</t>
          </list>
        </t>
	<t hangText="Authorization Server">
	  <list style="symbols">
	    <t>Register RS and manage corresponding security contexts.</t>
            <t>Register clients and including authentication credentials.</t>
	    <t>Allow Resource Onwers to configure and update access control
	    policies related to their registered RS'</t>
	    <t>Expose a service that allows clients to request tokens.</t>
            <t>Authenticate clients that wishes to request a token.</t>
	    <t>Process a token requests against the authorization
	    policies configured for the RS.</t>
	    <t>Expose a service that allows RS's to submit token introspection
	    requests.</t>
	    <t>Authenticate RS's that wishes to get an introspection 
	    response.</t>
	    <t>Process token introspection requests.</t>
	    <t>Optionally: Handle token revocation.</t>
          </list>
	</t>
        <t hangText="Client">
	  <list style="symbols">
	    <t>Discover the AS in charge of the RS that is to be targeted with
	    a request.</t>
            <t>Submit the token request (A).
	      <list style="symbols">
		<t>Authenticate towards the AS.</t>
		<t>Specify which RS, which resource(s), and which action(s)
		the request(s) will target.</t>
		<t>Specify preferences for communication security</t>
		<t>If raw public key (rpk) or certificate is used, make sure 
		the AS has the right rpk or certificate for this client.</t>
	      </list>
	    </t>
	    <t>Process the access token and client information (B)
	       <list style="symbols">
		<t>Check that the token has the right format (e.g. CWT).</t>
		<t>Check that the client information provides the necessary
		security parameters (e.g. PoP key, information on
		communication security protocols supported by the RS).</t>
	      </list>
	    </t>
	    <t>Send the token and request to the RS (C)
	      <list style="symbols">
		<t>Authenticate towards the RS (this could coincide with the
		proof of possession process).</t>
		<t>Transmit the token as specified by the AS (default is to an
		authorization information resource, alternative options are as
		a CoAP option or in the DTLS handshake).</t>
		<t>Perform the proof-of-possession procedure as specified for
		the type of used token (this may already have been taken care
		of through the authentication procedure).</t>
	      </list>
	    </t>
	    <t>Process the RS response (F)
	    requirements of the Requesting Party, when issuing requests
	    (e.g. minimum communication security requirements, trust
	    anchors).</t>
	    <t>Register the client at the AS.</t>
          </list>
	</t>
	<t hangText="Resource Server">
	  <list style="symbols">
	    <t>Expose a way to submit access tokens.</t>
            <t>Process an access token.
	      <list style="symbols">
		<t>Verify the token is from the right AS.</t>
		<t>Verify that the token applies to this RS.</t>
		<t>Check that the token has not expired (if the token provides
		expiration information).</t>
		<t>Check the token's integrity.</t>
		<t>Store the token so that it can be retrieved in the context
		of a matching request.</t>
	      </list>
	    </t>
	    <t>Process a request.
	     <list style="symbols">
	        <t>Set up communication security with the client.</t>
		<t>Authenticate the client.</t>
		<t>Match the client against existing tokens.</t>
		<t>Check that tokens belonging to the client actually
		authorize the requested action.</t>
		<t>Optionally: Check that the matching tokens are still valid (if this is
		possible.</t>
	      </list>
	    </t>
	    <t>Send a response following the agreed upon communication security.</t>
          </list>
	</t>
      </list></t>
    </section>

    <section anchor="app:cborMappingsForOAuth2Properties"
      title="CoAP and CBOR profiles for OAuth 2.0">

      <t>
        Many IoT devices can support OAuth 2.0 without any additional
        extensions, but for certain constrained settings additional profiling
        is needed.  In this appendix we define CoAP resources for the HTTP based
        token and introspection endpoints used in vanilla OAuth 2.0.  We also
        define a CBOR alternative to the JSON and form based POST structures
        used in HTTP.
      </t>

    <section anchor="tokenResource"
       title="Profile for Token resource">

       <t>The token resource is used by the client to obtain an access token by
       presenting its authorization grant or client credentials to the /token
       resource the AS.</t>

         <section anchor="tokenResourceRequest"
           title="Token Request">
           <t>The client makes a request to the token
             resource by sending a CBOR structure with the following
             attributes.</t>
           <t>
             <list style="hanging">
               <t hangText="grant_type:"><vspace blankLines="1"/>
                REQUIRED.  The grant type, "code",  "client_credentials",
                "password" or others.
               </t>
               <t hangText="client_id:"><vspace blankLines="1"/>
               OPTIONAL.  The client identifier issued to the holder of the
               token (client or RS) during the registration process.
               </t>
               <t hangText="client_secret:"><vspace blankLines="1"/>
               OPTIONAL.  The client secret.
               </t>
               <t hangText="scope:"><vspace blankLines="1"/>
               OPTIONAL.  The scope of the access request as described by
               <xref target="oauth2Overview" />.
               </t>
               <t hangText="aud:"><vspace blankLines="1"/>
                OPTIONAL.  Service-specific string identifier
                 or list of string identifiers representing the intended
                 audience for this token, as defined in 
                 <xref target="I-D.wahlstroem-ace-cbor-web-token"/>.
               </t>
               <t hangText="alg:"><vspace blankLines="1"/>OPTIONAL.  The value
               in the 'alg' parameter together with value from the
               'token_type' parameter allow the client to indicate the supported
               algorithms for a given token type.
               </t>
               <t hangText="key:"><vspace blankLines="1"/>
                OPTIONAL.  This field contains information
                 about the public key the client would like to bind to the
                 access token in the COSE Key Structure format.
               </t>
             </list>
           </t>

           <t>The parameters defined above use the following CBOR major
           types.</t>

           <t>
             <figure align="center" anchor="fig:cborTokenMappingRequest"
               title="CBOR mappings used in token requests">
               <artwork align="left"><![CDATA[
     /-----------+--------------+-----------------------\
     | Value     | Major Type   | Key                   |
     |-----------+--------------+-----------------------|
     | 0         | 0            | grant_type            |
     | 1         | 0            | client_id             |
     | 2         | 0            | client_secret         |
     | 3         | 0            | scope                 |
     | 4         | 0            | aud                   |
     | 5         | 0            | alg                   |
     | 6         | 0            | key                   |
     \-----------+--------------+-----------------------/
               ]]></artwork>
             </figure>
           </t>
         </section>

         <section anchor="tokenResourceResponse"
           title="Token Response">

           <t>The AS responds by sending a CBOR structure with the following
             attributes.</t>

           <t>
             <list style="hanging">

               <t hangText="access_token:"><vspace blankLines="1"/>
                 REQUIRED.  The access token issued by the authorization server.
               </t>

               <t hangText="token_type:"><vspace blankLines="1"/>
                 REQUIRED.  The type of the token issued. "pop" is recommended.
               </t>

              <t hangText="key:"><vspace blankLines="1"/>
                REQUIRED, if symmetric key cryptography is used.  A COSE Key
                Structure containing the symmetric proof of possession key.  The
                members of the structure can be found in section 7.1 of
                <xref target="I-D.ietf-cose-msg" />.
              </t>

              <t hangText="csp:"><vspace blankLines="1"/>
                REQUIRED.  Information on what communication protocol to use
                in the communication between the client and the RS.  Details on
                possible values can be found in
                <xref target="oauth2ProfilesCSP" />.
              </t>

               <t hangText="scope:"><vspace blankLines="1"/>
                 OPTIONAL, if identical to the scope requested by the client;
                 otherwise, REQUIRED.
               </t>

               <t hangText="alg:"><vspace blankLines="1"/>
                 OPTIONAL.  The 'alg' parameter provides further information
                 about the algorithm, such as whether a symmetric or an
                 asymmetric crypto-system is used.
               </t>

             </list>
           </t>

           <t>The parameters defined above use the following CBOR major 
           types.</t>

            <t>
              <figure align="center" anchor="fig:cborTokenMappingResponse"
                title="CBOR mappings used in token responses">
                <artwork align="left"><![CDATA[
      /-----------+--------------+-----------------------\
      | Value     | Major Type   | Key                   |
      |-----------+--------------+-----------------------|
      | 0         | 0            | access_token          |
      | 1         | 0            | token_type            |
      | 2         | 0            | key                   |
      | 3         | 0            | csp                   |
      | 4         | 0            | scope                 |
      | 5         | 0            | alg                   |
      \-----------+--------------+-----------------------/
                ]]></artwork>
              </figure>
            </t>
         </section>

<!-- 
         <section anchor="tokenResourceExample"
           title="Example">
           <t>
             An example of a token request done using CoAP and CBOR
             can be found in <xref target="ExCOff" />
           </t>
         </section>
--> 

      </section>



      <section anchor="introspectionResource"
         title="CoAP Profile for OAuth Introspection">

         <t>This section defines a way for a holder of access tokens, mainly
           clients and RS's, to get metadata like validity status, claims and
           scopes found in access token.  The OAuth Token Introspection
           specification <xref target="I-D.ietf-oauth-introspection"/> defines
           a way to validate the token using HTTP POST or HTTP GET.
           This document reuses the work done in the OAuth Token Introspection
           and defines a mapping of the request and response to CoAP
           <xref target="RFC7252"/> to be used by constrained devices.</t>

           <section anchor="introspectionResourceRequest"
             title="Introspection Request">
             <t>The token holder makes a request to the Introspection CoAP
               resource by sending a CBOR structure with the following
               attributes.</t>
             <t>
               <list style="hanging">
                 <t hangText="token:"><vspace blankLines="1"/>
                 REQUIRED.  The string value of the token.
                 </t>
                 <t hangText="resource_id:"><vspace blankLines="1"/>
                  OPTIONAL.  A service-specific string identifying the resource
                  that the client doing the introspection is asking about.
                 </t>
                 <t hangText="client_id:"><vspace blankLines="1"/>
                   OPTIONAL.  The client identifier issued to the holder of the 
                   token (client or RS) during the registration process.
                 </t>
                 <t hangText="client_secret:"><vspace blankLines="1"/>
                 OPTIONAL.  The client secret.
                 </t>
               </list>
             </t>

             <t>The parameters defined above use the following CBOR major 
             types:</t>

             <t>
               <figure align="center" anchor="fig:cborIntrospectionReq"
                 title="CBOR Mappings to Token Introspection Request Parameters.">
                 <artwork align="left"><![CDATA[
       /-----------+--------------+-----------------------\
       | Value     | Major Type   | Key                   |
       |-----------+--------------+-----------------------|
       | 0         | 0            | token                 |
       | 1         | 0            | resource_id           |
       | 2         | 0            | client_id             |
       | 3         | 0            | client_secret         |
       \-----------+--------------+-----------------------/
                 ]]></artwork>
               </figure>
             </t>
<!-- 
             <t>FIXME: Fix better mappings to CBOR.</t>
--> 
           </section>

           <section anchor="introspectionResourceResponse"
             title="Introspection Response">

              <t>If the introspection request is valid and authorized, the
              authorization server returns a CoAP message with the response 
              encoded as a CBOR structure in the payload of the message.  If the
              request failed client authentication or is invalid, the
              authorization server returns an error response using the CoAP 4.00 
              'Bad Request' response code.</t>

             <t>The JSON structure in the payload response includes the top-level
               members defined in Section 2.2 in the OAuth Token Introspection
               specification <xref target="I-D.ietf-oauth-introspection"/>.
               It is RECOMMENDED to only return the 'active' attribute 
               considering constrained nature of CoAP client and server 
               networks.</t>

             <t>Introspection responses in CBOR use the following
               mappings:</t>

             <t>
               <list style="hanging">

                 <t hangText="active:"><vspace blankLines="1"/>
                   REQUIRED.  The active key is an indicator of whether or not
                   the presented token is currently active.  The specifics of a
                   token's "active" state will vary depending on the 
                   implementation of the authorization server, and the
                   information it keeps about its tokens, but a "true" value
                   return for the "active" property will generally indicate that 
                   a given token has been issued by this authorization server, 
                   has not been revoked by the resource owner, and is within its
                   given time window of validity (e.g., after its
                   issuance time and before its expiration time).
                 </t>

                 <t hangText="scope:"><vspace blankLines="1"/>
                   OPTIONAL.  A string containing a space-separated list of
                  scopes associated with this token, in the format described in
                  Section 3.3 of OAuth 2.0 <xref target="RFC6749" />.
                 </t>

                <t hangText="client_id:"><vspace blankLines="1"/>
                  OPTIONAL.  Client identifier for the client that
                  requested this token.
                </t>

                <t hangText="username:"><vspace blankLines="1"/>
                  OPTIONAL.  Human-readable identifier for the resource owner 
                  who authorized this token.
                </t>

                <t hangText="token_type:"><vspace blankLines="1"/>
                  OPTIONAL.  Type of the token as defined in Section 5.1 of
                  OAuth 2.0 <xref target="RFC6749" /> or PoP token.
                </t>

                <t hangText="exp:"><vspace blankLines="1"/>
                  OPTIONAL.  Integer timestamp, measured in the number of 
                  seconds since January 1 1970 UTC, indicating when this token 
                  will expire, as defined in CWT 
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.
                </t>

                <t hangText="iat:"><vspace blankLines="1"/>
                  OPTIONAL.  Integer timestamp, measured in the number of
                  seconds since January 1 1970 UTC, indicating when this token
                  will expire, as defined in CWT 
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.
                </t>

                <t hangText="nbf:"><vspace blankLines="1"/>
                  OPTIONAL.  Integer timestamp, measured in the number of
                  seconds since January 1 1970 UTC, indicating when this token 
                  will expire, as defined in CWT 
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.
                </t>

                <t hangText="sub:"><vspace blankLines="1"/>
                  OPTIONAL.  Subject of the token, as defined in CWT
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.  Usually 
                  a machine-readable identifier of the resource owner who 
                  authorized this token.
                </t>

                <t hangText="aud:"><vspace blankLines="1"/>
                  OPTIONAL.  Service-specific string identifier or list of
                  string identifiers representing the intended audience for this
                  token, as defined in CWT 
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.
                </t>

                <t hangText="iss:"><vspace blankLines="1"/>
                  OPTIONAL.  String representing the issuer of this token, as
                  defined in CWT 
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />.
                </t>

                <t hangText="cti:"><vspace blankLines="1"/>
                  OPTIONAL.  String identifier for the token, as defined in CWT
                  <xref target="I-D.wahlstroem-ace-cbor-web-token" />
                </t>

               </list>
             </t>

             <t>The parameters defined above use the following CBOR major 
             types:</t>

              <t>
                <figure align="center" anchor="fig:cborIntrospectionResp"
                  title="CBOR Mappings to Token Introspection Response Parameters.">
                  <artwork align="left"><![CDATA[
/-----------+--------------+-----------------------\
| Value     | Major Type   | Key                   |
|-----------+--------------+-----------------------|
| 0         | 0            | active                |
| 1         | 0            | scopes                |
| 2         | 0            | client_id             |
| 3         | 0            | username              |
| 4         | 0            | token_type            |
| 5         | 0            | exp                   |
| 6         | 0            | iat                   |
| 7         | 0            | nbf                   |
| 8         | 0            | sub                   |
| 9         | 0            | aud                   |
| 10        | 0            | iss                   |
| 11        | 0            | cti                   |
\-----------+--------------+-----------------------/
                  ]]></artwork>
                </figure>
              </t>
<!-- 
              <t>FIXME: Fix better mappings to CBOR.</t>
--> 
           </section>

<!-- 
           <section anchor="introspectionResourceExample"
             title="Example">
             <t>
               An example of a introspection request done using CoAP and CBOR
               can be found in <xref target="ExCOff" />
             </t>
           </section>
-->    
        </section>

    </section>

<!-- ***************************************************** -->
      <section anchor="options" title="Deployment Examples">
        <t>There is a large variety of IoT deployments, as is indicated in 
        <xref target="constraints"/>, and this section highlights a few common 
        variants.  This section is not normative but illustrates how the
        framework can be applied.
        </t>

        <t>For each of the deployment variants there are a number of possible
        security setups between clients, resource servers and authorization
        servers.  The main focus in the following subsections is on how 
        authorization of a client request for a resource hosted by a RS is 
        performed.  This requires the the security of the requests and 
        responses between the clients and the RS to consider. 
        </t>

        <t>Note: CBOR diagnostic notation is used for examples of requests 
          and responses.</t>

<!-- ************************** -->


 <!-- ************************** -->
<section anchor="localTokenValidation" title="Local Token Validation">
  <t>In this scenario we consider the case where the resource server is offline, 
i.e. it is not connected to the AS at the time of the access request. 
This access procedure involves steps A, B, C, and F of <xref target="fig:protocolFlow"/>.
  </t>

  <t>Since the resource server must be able to verify the access token locally,
  self-contained access tokens must be used.</t>

    <t>This example shows the interactions between a client, the
    authorization server and a temperature sensor acting as a resource server.  Message
    exchanges A and B are shown in <xref target="fig:RSOffline"/>.</t>

    <t><list style="hanging">
      <t>A: The client first generates a public-private key pair used for
      communication security with the RS.</t>

      <t>The client sends the POST request to /token at the AS.  The request
      contains the public key of the client and the Audience parameter set to
      "tempSensorInLivingRoom", a value that the temperature sensor
      identifies itself with.  The AS evaluates the request and authorizes the
      client to access the resource.</t>

      <t>B: The AS responds with a PoP token and client information.  The PoP
      token contains the public key of the client, and the client information
      contains the public key of the RS.  For communication security
      this example uses DTLS RawPublicKey between the client and the RS. The issued 
      token will have a short validity time, i.e. 'exp' close to 'iat', 
      to protect the RS from replay attacks since it, that cannot 
      do introspection to check the tokens current validity. The token includes the
      claim "aif" with the authorized access that an owner of the
      temperature device can enjoy.  The 'aif' claim, issued by the AS,
      informs the RS that the owner of the token, that can prove
      the possession of a key is authorized to make a GET request
      against the /temperature resource and a POST request on the /firmware
      resource.</t>
 
      <t>Note: In this example we assume that the client knows what resource it
      wants to access, and is therefore able to request specific
      audience and scope claims for the access token.</t>
    </list></t>

    <t><figure align="center" anchor="fig:RSOffline"
               title="Token Request and Response Using Client Credentials.">
        <artwork align="left"><![CDATA[
         Authorization
  Client    Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"token"
    |         | Content-Type: application/cbor
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |  2.05   | Content-Type: application/cbor
    |         | Payload: <Response-Payload>
    |         |
        ]]></artwork>
    </figure></t>

    <t>The information contained in the Request-Payload and the
    Response-Payload is shown in <xref target="fig:RSOfflineReq"/>.

     <figure align="center" anchor="fig:RSOfflineReq"
             title="Request and Response Payload Details.">
      <artwork align="left"><![CDATA[
Request-Payload :
{
  "grant_type" : "client_credentials",
  "aud" : "tempSensorInLivingRoom",
  "client_id" : "myclient",
  "client_secret" : "qwerty"
}

Response-Payload :
{
  "access_token" : b64'SlAV32hkKG ...',
  "token_type" : "pop",
  "csp" : "DTLS",
  "key" : b64'eyJhbGciOiJSU0ExXzUi ...'
  "rpk" : b64'ZXlKaGJHY2lPaUpTVTBF ...'
}
        ]]></artwork>
    </figure></t>

    <t>The content of the "key" parameter and the access token are shown in
    <xref target="fig:BothcborMappingValuesAsymmetricKeyFormat"/> and
    <xref target="fig:BothcborMappingValueAsymmetricCWT"/>.</t>

    <t><figure align="center"
               anchor="fig:BothcborMappingValuesAsymmetricKeyFormat"
               title="Public Key of the RS.">
        <artwork align="left"><![CDATA[
{
  "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk',
  "kty" : "EC",
  "crv" : "P-256",
  "x"   : b64'MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4',
  "y"   : b64'4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM'
}
        ]]></artwork>
    </figure></t>

    <t><figure align="center"
               anchor="fig:BothcborMappingValueAsymmetricCWT"
               title="Access Token including Public Key of the Client.">
        <artwork align="left"><![CDATA[
{
  "aud" : "tempSensorInLivingRoom",
  "iat" : "1360189224",
  "exp" : "1360289224",
  "aif" :  [["/temperature", 0], ["/firmware", 2]],
  "cnf" : {
    "jwk" : {
      "kid" : b64'1Bg8vub9tLe1gHMzV76e8',
      "kty" : "EC",
      "crv" : "P-256",
      "x" : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
      "y" : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
    }
  }
}
        ]]></artwork>
    </figure></t>

    <t>Messages C and F are shown in
    <xref target="fig:RSOfflinePostAccessTokenAsymmetric"/> -
    <xref target="fig:RSOfflineDTLSRequestAndResponse"/>.

    <list style="hanging">
      <t>C: The client then sends the PoP token to the /authz-info resource at
      the RS.  This is a plain CoAP request, i.e. no transport or application 
      layer security between client and RS, since the token is integrity protected 
      between AS and RS.  The RS verifies that the PoP token was created by a 
      known and trusted AS, is valid, and responds to the client.  The RS caches 
      the security context together with authorization information about this client 
      contained in the PoP token.</t>

    <t><figure align="center" anchor="fig:RSOfflinePostAccessTokenAsymmetric"
               title="Access Token provisioning to RS">
      <artwork align="left"><![CDATA[
           Resource
 Client     Server
    |         |
C:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"authz-info"
    |         | Payload: SlAV32hkKG ...
    |         |
    |<--------+ Header: 2.01 Created
    |  2.01   |
    |         |
]]></artwork>
    </figure></t>   

      <t>The client and the RS runs the DTLS handshake using the raw 
      public keys established in step B and C.</t>

      <t>The client sends the CoAP request GET to /temperature on RS over
      DTLS.  The RS verifies that the request is authorized, based on 
      previously established security context.</t>

      <t>F: The RS responds with a resource representation over DTLS.</t>
    </list></t>

    <t><figure align="center" anchor="fig:RSOfflineDTLSRequestAndResponse"
               title="Resource Request and Response protected by DTLS.">
      <artwork align="left"><![CDATA[
           Resource
 Client     Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   using Raw Public Keys
    |         |
    +-------->| Header: GET (Code=0.01)
    | GET     | Uri-Path: "temperature"
    |         |
    |         |
    |         |
F:  |<--------+ Header: 2.05 Content
    | 2.05    | Payload: <sensor value>
    |         |
      ]]></artwork>
    </figure></t>
</section>


 <!-- ************************** -->

<section anchor="introspectionAidedTokenValidation" title="Introspection Aided Token Validation">

  <t>In this deployment scenario we assume that a client is not be able to 
  access the AS at the time of the access request.  Since the RS is, however, 
  connected to the back-end infrastructure it can make use of token 
  introspection.  This access procedure involves steps A-F of 
  <xref target="fig:protocolFlow"/>, but assumes steps A and B have been
  carried out during a phase when the client had connectivity to AS.
  </t>

  <t>Since the client is assumed to be offline, at least for a certain period of 
  time, a pre-provisioned access token has to be long-lived.  The resource 
  server may use its online connectivity to validate the access token with the
  authorization server, which is shown in the example below.</t>

    <t>In the example we show the interactions between an offline client
    (key fob), a resource server (online lock), and an authorization server.  We
    assume that there is a provisioning step where the client has access to the
    AS.  This corresponds to message exchanges A and B which are shown in
    <xref target="fig:cOffline"/>.
    </t>
    <t>Authorization consent from the resource owner can be pre-configured, 
    but it can also be provided via an interactive flow with the resource 
    owner.  An example of this for the key fob case could be that the 
    resource owner has a connected car, he buys a generic key that he 
    wants to use with the car.  To authorize the key fob he connects it 
    to his computer that then provides the UI for the device.  After 
    that OAuth 2.0 implicit flow can used to authorize the key for 
    his car at the the car manufacturers AS.</t>

      <t>Note: In this example the client does not know the exact door it 
        will be used to access since the token request is not send at the 
        time of access. So the scope and audience claims is set quite 
        wide to start with and new values different form the 
        original once can be returned from introspection later on.</t>
            <t>
      <list style="hanging">
        <t>A: The client sends the request using POST to /token at AS.  The
        request contains the Audience parameter set to  "PACS1337" (PACS, Physical Access System), a
        value the that the online door in question identifies itself with.  The
        AS generates an access token as on opaque string, which it can match to
        the specific client, a targeted audience and a symmetric key.</t>

        <t>B: The AS responds with the an access token and client information,
        the latter containing a symmetric key.
        Communication security between C and RS will be DTLS and PreSharedKey. 
        The PoP key being used as the PreSharedKey.
        </t>
      </list>
    </t>

    <t><figure align="center" anchor="fig:cOffline"
               title="Token Request and Response using Client Credentials.">
      <artwork align="left"><![CDATA[

         Authorization
 Client     Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"token"
    |         | Content-Type: application/cbor
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |         | Content-Type: application/cbor
    |  2.05   | Payload: <Response-Payload>
    |         |
    ]]></artwork>
    </figure></t>

    <t>The information contained in the Request-Payload and the
    Response-Payload is shown in <xref target="fig:cOfflineReq"/>.

     <figure align="center" anchor="fig:cOfflineReq"
             title="Request and Response Payload for C offline">
      <artwork align="left"><![CDATA[
Request-Payload:
{
  "grant_type" : "client_credentials",
  "aud" : "lockOfDoor4711",
  "client_id" : "keyfob",
  "client_secret" : "qwerty"
}

Response-Payload:
{
  "access_token" : b64'SlAV32hkKG ...'
  "token_type" : "pop",
  "csp" : "DTLS",
  "key" : b64'eyJhbGciOiJSU0ExXzUi ...'
}
      ]]></artwork>
    </figure></t>

    <t>The access token in this case is just an opaque string referencing
   the authorization information at the AS.</t>

    <t><list style="hanging">
        <t>C: Next, the client POSTs the access token to the /authz-info
        resource in the RS.  This is a plain CoAP request, i.e. no 
        DTLS between client and RS.  Since the token is an opaque string,
        the RS cannot verify it on its own, and thus defers to respond the 
        client with a status code until after step E.</t>

        <t>D: The RS forwards the token to the /introspect
        resource on the AS.  Introspection assumes a secure connection
        between the AS and the RS, e.g. using transport of application layer security,  which
  is not detailed in this example.
        </t>

        <t>E: The AS provides the introspection response containing claims
  about the token.  This includes the confirmation key (cnf) claim
        that allows the RS to verify the client's proof of possession in
  step F.</t>

        <t>After receiving message E, the RS responds to the client's POST in
        step C with Code 2.01 Created.</t>

        <t><figure align="center" anchor="fig:cOfflineIntrospection"
            title="Token Introspection for C offline">
            <artwork align="left"><![CDATA[
           Resource
  Client    Server
    |         |
C:  +-------->| Header: POST (T=CON, Code=0.02)
    |  POST   | Uri-Path:"authz-info"
    |         | Content-Type: "application/cbor"
    |         | Payload: b64'SlAV32hkKG ...''
    |         |
    |         |     Authorization
    |         |       Server
    |         |          |
D:  |         +--------->| Header: POST (Code=0.02)
    |         |  POST    | Uri-Path: "introspect"
    |         |          | Content-Type: "application/cbor"
    |         |          | Payload: <Request-Payload>
    |         |          |
E:  |         |<---------+ Header: 2.05 Content
    |         |  2.05    | Content-Type: "application/cbor"
    |         |          | Payload: <Response-Payload>
    |         |          |         
    |         |          
C:  |<--------+ Header: 2.01 Created
    |  2.01   |
    |         |
]]></artwork>
        </figure></t>

        <t>The information contained in the Request-Payload and the
        Response-Payload is shown in <xref target="fig:cOfflineIntroReq"/>.

        <figure align="center" anchor="fig:cOfflineIntroReq"
                title="Request and Response Payload for Introspection">
          <artwork align="left"><![CDATA[
Request-Payload:
{
  "token" : b64'SlAV32hkKG...',
  "client_id" : "FrontDoor",
  "client_secret" : "ytrewq"
}

Response-Payload:
{
  "active" : true,
  "aud" : "lockOfDoor4711",
  "scope" : "open, close",
  "iat" : 1311280970,
  "cnf" : {
    "ck" : b64'JDLUhTMjU2IiwiY3R5Ijoi ...'
  }
}
          ]]></artwork>
        </figure></t>
      </list>
  </t>

<t>
    <list style="hanging">
        <t>
            The client uses the symmetric PoP key to establish a DTLS 
            PreSharedKey secure connection to the RS. The CoAP request PUT is 
            sent to the uri-path /state on RS changing state of the door to locked.
        </t>
        <t>
            F: The RS responds with a appropriate over the secure DTLS channel.
        </t>
    </list>
</t>
        <t><figure align="center" anchor="fig:cOfflineDTLSRequestAndResponse"
            title="Resource request and response protected by OSCOAP">
            <artwork align="left"><![CDATA[
           Resource
  Client    Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   using Pre Shared Key
    |         |
    +-------->| Header: PUT (Code=0.03)
    | PUT     | Uri-Path: "state"
    |         | Payload: <new state for the lock>
    |         |
F:  |<--------+ Header: 2.04 Changed
    | 2.04    | Payload: <new state for the lock>
    |         |
            ]]></artwork>
        </figure></t>
    </section>

</section>
    <section anchor="app:changelog" title="Document Updates">
      <section anchor="app:f1t2" title="Version -00 to -01">
	<t><list style="symbols">
	  <t>Changed 5.1. from "Communication Security Protocol" to "Client
	  Information".</t> 
	  <t>Major rewrite of 5.1 to clarify the information exchanged between
	  C and AS in the PoP token request profile for IoT.
	  <list style="symbols">
	    <t>Allow the client to indicate preferences for the communication
	    security protocol.</t>
	    <t>Defined the term "Client Information" for the additional
	    information returned to the client in addition to the access
	    token.</t>
	    <t>Require that the messages between AS and client are secured,
	    either with (D)TLS or with COSE_Encrypted wrappers.</t>
	    <t>Removed dependency on OSCoAP and added generic text about
	    object security instead.</t>
	    <t>Defined the "rpk" parameter in the client information to  
	    transmit the raw public key of the RS from AS to client.</t>
	    <t>(D)TLS MUST use the PoP key in the handshake (either as
	    PSK or as client RPK with client authentication).</t>
	    <t>Defined the use of x5c, x5t and x5tS256 parameters when a
	    client certificate is used for proof of possession.</t>
	    <t>Defined "tktn" parameter for signaling for how to tranfer the
	    access token.</t>
	  </list></t>
	  <t>Added 5.2. the CoAP Access-Token option for transfering access
	  tokens in messages that do not have payload.</t>
	  <t>5.3.2. Defined success and error responses from the RS when
	  receiving an access token.</t>
	  <t>5.6.:Added section giving guidance on how to handle token
	  expiration in the absence of reliable time.</t>
	  <t>Appendix B Added list of roles and responsibilities for C, AS and
	  RS.</t>
	</list></t>
      </section>
    </section>
  </back>
</rfc>
